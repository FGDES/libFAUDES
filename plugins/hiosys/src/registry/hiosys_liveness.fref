<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE ReferencePage SYSTEM "http://www.faudes.org/dtd/1.0/referencepage.dtd">
<ReferencePage chapter="Reference" section="HioSys" page="4_Liveness_Properties" title="HioSys - Liveness">

<h1>
HioSys PlugIn 
</h1>
<h2>
I/O-Based Liveness: Completeness and Yp-liveness
</h2>

<p>
A majority of the approaches to control of DES that regard liveness use the technique of marking
particular strings of plant and/or specification to express desired liveness properties. In most of
these approaches, the respective objective of controller design is to achieve or preserve the permanent
chance for any string of the closed loop to be extended to a marked string.
Our notion of liveness is different in that it requires output events to occur persistently rather than
strings/states to be reachable and thus is not based on marking. First, we define the notion of a
YP-live language and then identify two coupled liveness properties adequate for our setting.
</p>

<h3>
Definition: <fimath>Y_P</fimath>-liveness
</h3>
<p>
Let <fimath>L</fimath> be a regular language and <fimath>Y_P</fimath> be an alphabet.
</p>
<p>
If
<fimath>(\forall w \in L^\infty)[ \Pro{YP}(w) \in Y_P^{\omega}]</fimath> ,
then <fimath>L</fimath> is said to be <fimath>Y_P</fimath>-live.
</p>
<p>
Apparently, any subset of a <fimath>Y_P</fimath>-live language is also <fimath>Y_P</fimath>-live, which is important for a) 
discussing the liveness of an I/O plant within different
external configurations (modularity) and b) abstraction-based control. Using <fimath>Y_P</fimath>-liveness, we can
describe the liveness properties of an I/O plant as follows.
</p>

<h3>
Definition: I/O Plant - Liveness Properties
</h3>

<p>
Let <fimath>S_{PE} = (U_P,Y_P,U_E,Y_E,L_{PE})</fimath> be an I/O plant and let <fimath>S_P = (U_P,Y_P,L_P)</fimath> and <fimath>S_E = (U_E,Y_E,L_E)</fimath>
be constraints.
<ul class="12">
<li>If <fimath>L_P || L_{PE} || L_E</fimath> is complete (see <ffnct>IsComplete</ffnct>), then <fimath>S_{PE}</fimath> said to be complete w.r.t. the constraints <fimath>S_P</fimath>
 and <fimath>S_E</fimath>.</li>
<li>If
<fimath>(\forall w \in (L_P || L_{PE} || L_E)^\infty)[ \Pro{YP}(w) \in Y_P^{\omega} ]</fimath>
then the plant said to be <fimath>Y_P</fimath>-live w.r.t. the constraints <fimath>S_P</fimath> and <fimath>S_E</fimath>.</li>
</ul>
</p>

<p>
Completeness requires the plant to persistently issue events, i.e. prohibits deadlocks. Moreover, the
completeness property guarantees that each sequence of events contributes to an infinite sequence
of events in the language limit considered by <fimath>Y_P</fimath>-liveness. The second liveness
property, <fimath>Y_P</fimath>-liveness, requires that any infinite sequence of events must include an infinite number
of measurement events reported to the operator (no livelocks between any two <fimath>Y_P</fimath>-events). Hence,
both properties when put together indeed guarantee that an infinite sequence of measurement
events is generated by the plant under constraints and, in return, influence by the operator
is persistently possible. Technically, <fimath>L_P || L_{PE} || LE = \emptyset</fimath> provokes both liveness conditions to be
met trivially.
The <a href="hiosy_synth.html">HioSys synthesis functions</a> design an I/O controller such that the above liveness properties
are met for the external view on the closed loop under constraints.
</p>


<p>
<a href="hiosys_index.html">HioSys Home</a>
</p>
</ReferencePage>

  
