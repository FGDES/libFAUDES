/** rti2code.cpp  Utility to generate registry initialisation code from rti files */

/* FAU Discrete Event Systems Library (libfaudes)

Copyright (C) 2009 Ruediger Berndt
Copyright (C) 2010, 2023, 2025 Thomas Moor

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */
	 

#include <string>
#include <iostream>
#include <fstream>
#include "corefaudes.h"


using namespace faudes;

// ******************************************************************
// error exit
// ******************************************************************

void usage(const std::string& rMessage="") {
  // UI hints
  if(rMessage!="") {
    std::cerr << rMessage << std::endl;
    std::cout << "" << std::endl;
  }
  std::cerr << "rti2code: " << VersionString()  << std::endl;
  std::cerr << std::endl;
  std::cerr << "utility to generates c code from an rti-file to " << std::endl;
  std::cerr << "1) register faudes-types and -functions with the run-time interface," << std::endl;
  std::cerr << "2) extract c declarations for bindings interface code." << std::endl;
  std::cerr << std::endl;
  std::cerr << "usage:" << std::endl;
  std::cerr << " rti2code [-swig|-loader] <rti input file> <output basename>" << std::endl;
  std::cerr << " rti2code -merge <rti input files> <output rti-file>" << std::endl;
  std::cerr << std::endl;
  std::cerr << "[note: the -loader flag will produce .h/.cpp files to instantiate prototypes" << std::endl;
  std::cerr << "[note: the -swig flag will produce a .i file for swig include" << std::endl;
  std::cerr << "[note: the -flat flag circumvents an issue with SWIG pre 4.1.0]" << std::endl;
  exit(1);
}


// ******************************************************************
// main programm
// ******************************************************************

int main(int argc, char *argv[]) {

  // config
  bool loader=false;
  bool swig=false;
  bool flat=false;
  bool merge=false;

  // primitive command line parser
  int pos=1;
  for(; pos<argc; pos++) {
    std::string option(argv[pos]);
    // option: help
    if((option=="-?") || (option=="--help")) {
      usage();
      continue;
    }
    // option: loader
    if(option=="-loader") {
      loader=true;
      continue;
    }
    // option: swig
    if(option=="-swig") {
      swig=true;
      continue;
    }
    // option: flat
    if(option=="-flat") {
      flat=true;
      continue;
    }
    // option: merge
    if(option=="-merge") {
      merge=true;
      continue;
    }
    // option: unknown
    if(option.c_str()[0]=='-') {
      usage("unknown option "+ option);
      continue;
    }
    // break for args
    break;
  }

  // mode test
  if(merge && (loader || swig)) {
    usage("mismatching options: either merge or code generation");
  }    
  if(!merge && !(loader || swig)) {
    usage("mismatching options: either merge or code generation");
  }    
  if(flat && !swig) {
    usage("mismatching options: flat is only applicable to swig");
  }    
  if(merge && (argc-pos <2)) {
    usage("mismatching agruments: to few files to merge");
  }
  if(!merge && (argc-pos !=2)) {
    usage("mismatching agruments: need one source and one destination for code generation");
  }

  // Merge mode -- get this done first
  if(merge) {
    // Load from files
    for(; pos< argc-1; pos++) {
      TypeRegistry::G()->MergeDocumentation(std::string(argv[pos]));
      FunctionRegistry::G()->MergeDocumentation(std::string(argv[pos]));
    }
    // Dump
    if(std::string(argv[argc-1]) != "-") {
      SaveRegistry(std::string(argv[argc-1]));
    } else {
      SaveRegistry();
    }
    return 0;
  }

  // code-gen modes loader/swig
  LoadRegistry(argv[pos++]);

  // Code output streams
  std::ofstream rtiheader;
  std::ofstream rticode;
  std::ofstream swigheader;
  if(loader) {
    rtiheader.open((std::string(argv[pos])+".h").c_str(), std::ios::out);
    rticode.open((std::string(argv[pos])+".cpp").c_str(), std::ios::out);
  }
  if(swig){
    swigheader.open((std::string(argv[pos])+".i").c_str(), std::ios::out);
  }

  // Introduce myself
  if(loader) {
    rtiheader << "/* rti2code: autogenerated libFAUDES rti registration: "; 
    rtiheader << VersionString() << " "  << PluginsString() << " */" << std::endl << std::endl; 
    rticode   << "/* rti2code: autogenerated libFAUDES rti registration: "; 
    rticode   << VersionString() << " "  << PluginsString() << " */" << std::endl << std::endl;
  }
  if(swig) {
    swigheader << "/* rti2code: autogenerated libFAUDES swig bindings declarations: "; 
    swigheader << VersionString() << " "  << PluginsString() << " */" << std::endl << std::endl;
  }

  // C++ static objects: auto load types
  if(loader) {
    rticode << "namespace faudes {" << std::endl;
    rticode << "/* Auto-register faudes types */" << std::endl;
  }

  // Traverse type registry to figure faudes types
  if(loader) {
    TypeRegistry::Iterator  tit;
    int tcnt;
    for(tit=TypeRegistry::G()->Begin(), tcnt=1; tit!=TypeRegistry::G()->End();tit++,tcnt++) {
      // Get c/f type 
      std::string ctype=tit->second->CType();
      std::string ftype=tit->second->Name();
      // Bail out if no C type specified
      if(ctype=="") continue;
      // Remove name space faudes
      size_t pos=ctype.find("faudes::");
      if(pos!=std::string::npos) 
        ctype=ctype.substr(std::string("faudes::").length());
      // Bail out no auto-registration specified
      if(!tit->second->AutoRegistered()) continue;
      // report
      std::cout << "rti2code: generating auto-registration code for \"" << ftype << "\"" << std::endl;
      // Produce c code
      std::string rtiname = std::string("gRti") + ToStringInteger(tcnt) + "Register" + ftype;
      rticode << "AutoRegisterType<" << ctype << "> " << rtiname << "(\"" << ftype <<"\");";
      rticode << std::endl;
      // Extra data set: element tag
      if(tit->second->ElementTag()!="") {
        rtiname = std::string("gRti") + ToStringInteger(tcnt) + "ElementTag" + ftype;
        rticode << "AutoRegisterElementTag<" << ctype << "> " << rtiname << "(\"" << ftype << 
          "\", \"" << tit->second->ElementTag() << "\");";
        rticode << std::endl;
      }
      // Extra data set: element tag
      if(tit->second->ElementType()!="") {
        rtiname = std::string("gRti") + ToStringInteger(tcnt) + "ElementType" + ftype;
        rticode << "AutoRegisterElementType<" << ctype << "> " << rtiname << "(\"" << ftype << 
          "\", \"" << tit->second->ElementType() << "\");";
        rticode << std::endl;
      }
    }
  }

  // C++ static objects: auto load types end
  if(loader) {
    rticode << "} // namespace" << std::endl;
  }

  // C++ function declaration: load types
  if(loader) {
    rtiheader << "namespace faudes {" << std::endl;
    rtiheader << "void LoadRegisteredTypes(void);" << std::endl;
    rtiheader << "} // namespace" << std::endl;
  }

  // C++ function definition: load types
  if(loader) {
    rticode << "namespace faudes {" << std::endl;
    rticode << "/* Register faudes types */" << std::endl;
    rticode << "void LoadRegisteredTypes(void) {" << std::endl;
  }

  // Traverse type registry to figure faudes types
  if(loader) {
    TypeRegistry::Iterator  tit;
    for(tit=TypeRegistry::G()->Begin(); tit!=TypeRegistry::G()->End();tit++) {
      // Get C type 
      std::string ctype=tit->second->CType();
      // Bail out if no c type specified
      if(ctype=="") continue;
      // Remove name space faudes
      size_t pos=ctype.find("faudes::");
      if(pos!=std::string::npos) 
        ctype=ctype.substr(std::string("faudes::").length());
      // Report
      std::cout << "rti2code: generating registration code for \"" << tit->second->Name() << "\"" << std::endl;
      // Produce c code
      rticode << "  TypeRegistry::G()->Insert<" << ctype << ">(\"" << tit->second->Name() <<"\");";
      rticode << std::endl;
    }
  }

  // C++ function definition: load types end
  if(loader) {
    rticode << "}" << std::endl;
    rticode << "} // namespace" << std::endl;
  }


  // C++ function declaration: load functions
  if(loader) {
    rtiheader << "namespace faudes {" << std::endl;
    rtiheader << "void LoadRegisteredFunctions(void);" << std::endl;
    rtiheader << "} // namespace" << std::endl;
  }

  // C++ function definition: load functions
  if(loader) {
    rticode << "namespace faudes {" << std::endl;
    rticode << "/* Register faudes functions */" << std::endl;
    rticode << "void LoadRegisteredFunctions(void) {" << std::endl;
  }

  // C++ class definition: Function derivates 
  if(loader) {
    rtiheader << "namespace faudes {" << std::endl;
  }

  // Traverse function registry: define rti functions
  int fcnt=0;
  FunctionRegistry::Iterator  fit;
  for(fit=FunctionRegistry::G()->Begin(); fit!=FunctionRegistry::G()->End();fit++, fcnt++) {
    // Current function definition
    const FunctionDefinition* fdef = fit->second;
    // Get C type and faudes function name
    std::string ctype=fdef->CType();
    std::string fname = fdef->Name();  
    // Bail out if no c type specified
    if(ctype=="") continue;
    // Remove name space faudes
    size_t pos=ctype.find("faudes::");
    if(pos!=std::string::npos) 
      ctype=ctype.substr(std::string("faudes::").length());
    // Bail out if no signature
    if(fdef->VariantsSize()==0) {
      std::cout << "rti2cocde: function registration: " << fname << ": no signatures" << std::endl;
      continue;
    }
    // Interpret signatures: set up type array
    std::vector< std::vector<std::string> > cparams;
    std::vector< std::vector<Parameter::ParamAttr> > cattrib;
    std::vector< std::vector<bool> > cretval;
    cparams.resize(fdef->VariantsSize());
    cattrib.resize(fdef->VariantsSize());
    cretval.resize(fdef->VariantsSize());
    // Loop all signatures
    for(int i=0; i<fdef->VariantsSize(); i++) {
      const Signature& sigi=fdef->Variant(i);
      int retcount=0;
      for(int j=0; j<sigi.Size(); j++) {
        // Retrieve faudes type and attrib
        std::string ftype=sigi.At(j).Type();
	Parameter::ParamAttr fattr=sigi.At(j).Attribute();
	bool fcret=sigi.At(j).CReturn();   
        // Count ret values
        if(fcret) retcount++;
        // Bail out on unknown faudestype
        if(!TypeRegistry::G()->Exists(ftype)) break;
        // Get corresponding ctype
        std::string ctype=TypeRegistry::G()->Definition(ftype).CType();
        // Bail out on unknown ctype
        if(ctype=="") break;
        // bail out on non-out ret value
        if(fcret && !(fattr==Parameter::Out)) break;
        // Bail out on undef attribute
        if(fattr==Parameter::UnDef) break;
        // Bail out on more than one ret values
        if(retcount>1) break;
        // Remove name space faudes
        size_t pos=ctype.find("faudes::");
        if(pos!=std::string::npos) 
          ctype=ctype.substr(std::string("faudes::").length());
        // Param ok
        cparams.at(i).push_back(ctype);
        cattrib.at(i).push_back(fattr);
        cretval.at(i).push_back(fcret);
      } 
      // Test for signature error
      if((int) cparams.at(i).size()!=sigi.Size()) {
        std::cout << "rti2code: function registration: " << fname << ": cannot interpret signature " 
		  << sigi.Name() << std::endl;
        cparams.resize(i);
        break;
      }
    }
    // Report
    std::cout << "rti2code: generating rti wrapper for \"" << fdef->Name() << "\"" << 
      " #" << cparams.size() << " variants" << std::endl;
    std::string rtiname = std::string("Rti") + ToStringInteger(fcnt) + ctype;
    // Produce c code: register all functions function
    if(loader) {
      rticode << "  FunctionRegistry::G()->Insert<" << rtiname << ">(\"" << fname <<"\");" << std::endl;
    }
    // Produce c code: class declaration intro
    if(loader) {
      rtiheader << "/* Function class for C++ function " << ctype << "*/" << std::endl;
      rtiheader << "class " << rtiname << " : public Function { " << std::endl;
      rtiheader << "public:" << std::endl;
      rtiheader << "  using Function::operator=;" << std::endl;
      rtiheader << rtiname << "(const FunctionDefinition* fdef) : Function(fdef) {};" << std::endl;
      rtiheader << "virtual Function* New(void) const { return new " << rtiname << "(pFuncDef); };" << std::endl;
      rtiheader << "protected:" << std::endl;
    }
    // Produce c code: function class: have typed param
    if(loader) {
      for(unsigned int i=0; i<cparams.size(); i++) 
        for(unsigned int j=0; j<cparams.at(i).size(); j++) 
          rtiheader << cparams.at(i).at(j) << "* " << "mP_" << i << "_" << j << ";" << std::endl;
    }
    // Produce c code: function class: do type check
    if(loader) {
      rtiheader << "virtual bool DoTypeCheck(int n) {" << std::endl;
      rtiheader << "  bool res=false;" << std::endl;
      rtiheader << "  switch(mVariantIndex) { "<< std::endl;
      for(unsigned int i=0; i<cparams.size(); i++) {
        rtiheader << "  case " << i << ": { // variant " << fdef->Variant(i).Name() << std::endl;
        rtiheader << "    switch(n) { "<< std::endl;
        for(unsigned int j=0; j<cparams.at(i).size(); j++) {
          rtiheader << "    case " << j << ": ";
          rtiheader << "    res=DoTypeCast<" << cparams.at(i).at(j) << ">(" << j << ", mP_" << i <<"_" << j << "); ";
          rtiheader << "break; "<< std::endl;
        }
        rtiheader << "    default: break; " << std::endl;
        rtiheader << "    } "<< std::endl;
        rtiheader << "    break; "<< std::endl;
        rtiheader << "  } "<< std::endl;
      }
      rtiheader << "  default: break; " << std::endl;
      rtiheader << "  } "<< std::endl;
      rtiheader << "  return res;" << std::endl;
      rtiheader << "};" << std::endl;
    }
    // Produce c code: function class: do execute
    if(loader) {
      rtiheader << "virtual void DoExecute(void) {" << std::endl;
    }
    // Produce c code: do execute: switch variant
    if(loader) {
      rtiheader << "  switch(mVariantIndex) { "<< std::endl;
      for(unsigned int i=0; i<cparams.size(); i++) {
        rtiheader << "  case " << i << ": { // variant " << fdef->Variant(i).Name() << std::endl;
        rtiheader << "    ";
        // Figure return value (if any)
        for(unsigned int j=0; j<cparams.at(i).size(); j++) {
          if(!cretval.at(i).at(j)) continue;
          // Special case: integer
          if(cparams.at(i).at(j) == "Integer") {
            rtiheader << "*(mP_" << i << "_" << j << "->CReference()) = ";
          } else 
          // Special case: boolean
	    if(cparams.at(i).at(j) == "Boolean") {
            rtiheader << "*(mP_" << i << "_" << j << "->CReference()) = ";
          } else
          // Special case: integer
          if(cparams.at(i).at(j) == "String") {
            rtiheader << "*(mP_" << i << "_" << j << "->CReference()) = ";
          } else
          // Std case
	    rtiheader << "*mP_" << i << "_" << j  << " = ";
	}
	// Function name
        rtiheader << ctype <<"(";
        // Parameters
        int parpos=0;
        for(unsigned int j=0; j<cparams.at(i).size(); j++) {
          if(cretval.at(i).at(j)) continue;
          if((parpos++)!=0) rtiheader << " ,";
          // Special case: integer
          if(cparams.at(i).at(j) == "Integer") {
            rtiheader << "*(mP_" << i << "_" << j << "->CReference())";
          } else 
          // Special case: boolean
            if(cparams.at(i).at(j) == "Boolean") {
            rtiheader << "*(mP_" << i << "_" << j << "->CReference())";
          } else
          // Special case: integer
          if(cparams.at(i).at(j) == "String") {
            rtiheader << "*(mP_" << i << "_" << j << "->CReference())";
          } else
          // Std case
            rtiheader << "*mP_" << i << "_" << j;
	}
        rtiheader << "); break; };" << std::endl;
      }
      // Produce c code: switch variant; done
      rtiheader << "  default: break; " << std::endl;
      rtiheader << "  }; "<< std::endl;
      // Produce c code: do execute: done
      rtiheader << "}; "<< std::endl;
      // Produce c code: function class: done
      rtiheader << "};"  << std::endl;
    }
    
    // Produce swig code: function definition(s)
    if(swig) {
      swigheader << "/* faudes-function \"" << fname << "\" */" << std::endl;
    }
    // Figure my plugin to insert a conditional
    if(swig) {
      if(!flat) {
        std::string plugin=fdef->PlugIn();
        swigheader << "#if " << "( SwigModule == \"Swig" << plugin << "\")";
        //luaheader << " || ( SwigModule == \"SwigLibFaudes\")";  // requires SWIG 4.1
        swigheader << std::endl;
      }
    }
    // Use C-type function name
    if(swig) {
      if(ctype!=fname)
        swigheader << "%rename(" << fname << ") " << ctype << ";" << std::endl;
    }

    // Prepare swig code: preprocessed array
    if(swig) {
      std::vector< std::string > lfdefs;
      std::vector< std::string > lrtypes;
      std::vector< std::string > lhelp;
      // Prepare swig code: generate per signature
      for(unsigned int i=0; i<cparams.size(); i++) {
        // Create ctype function declaration: return value
        std::string lrtype="void";
        for(unsigned int j=0; j<cparams.at(i).size(); j++) {
          if(!cretval.at(i).at(j)) continue;
          // Special case: integer
          if(cparams.at(i).at(j) == "Integer") {
            lrtype="long int";
          } else 
          // Special case: boolean
  	  if(cparams.at(i).at(j) == "Boolean") {
            lrtype="bool";
          } else
          // Special case: string
          if(cparams.at(i).at(j) == "String") {
            lrtype="std::string";
          } else
          // Std case ctype as refernce
	  lrtype = cparams.at(i).at(j);
          // No more than one return value
          break;
        }
        lrtypes.push_back(lrtype);
        // Create ctype function declaration: function body
        std::string lfdef = ctype + "(";
        // Create ctype function declaration: parameters
        int parpos=0;
        for(unsigned int j=0; j<cparams.at(i).size(); j++) {
          if(cretval.at(i).at(j)) continue;
          if((parpos++)!=0) lfdef += ", ";
          // Have const for +In+
  	  if(cattrib.at(i).at(j)==Parameter::In)
            lfdef +=  "const ";
          // Special case: integer
          if(cparams.at(i).at(j) == "Integer") {
            lfdef += "long int&";
          } else 
          // Special case: boolean
	  if(cparams.at(i).at(j) == "Boolean") {
            lfdef += "bool&";
          } else
          // Special case: string
          if(cparams.at(i).at(j) == "String") {
            lfdef += "std::string&";
          } else
          // Std case ctype as refernce
  	    lfdef += cparams.at(i).at(j) + "&";
          // Mark elementary outputs
          if(cparams.at(i).at(j) == "Boolean" || cparams.at(i).at(j) == "String" 
             || cparams.at(i).at(j) == "Integer")
	  if(cattrib.at(i).at(j)==Parameter::Out)
            lfdef += " OUTPUT";
        }
        // End of function declaration
        lfdef += ")"; 
        lfdefs.push_back(lfdef);
        // Add help entry: build nice signature
        std::string luasig = " " + fname + "(";
        bool leftcomma = false;
        bool rightcomma = false;
        for(unsigned int j=0; j<cparams.at(i).size(); j++) {
          // Special case: elementary output
          if(cparams.at(i).at(j) == "Boolean" || cparams.at(i).at(j) == "String" 
             || cparams.at(i).at(j) == "Integer")
	  if(cattrib.at(i).at(j)==Parameter::Out) {
            if(leftcomma) luasig = "," + luasig;
	    //            if(leftcomma) luasig = ", " + luasig; // need tab in help system?
	    luasig=cparams.at(i).at(j) + luasig;
            leftcomma=true;
	    continue;
	  }
          // Std case
          if(rightcomma) luasig += ", ";
          const Signature& sigi=fdef->Variant(i);
	  luasig += sigi.At(j).Str();
          rightcomma=true;
        }  
        luasig+=")";
        // Add help entry: add with topic
        if(fdef->TextDoc()!=""){
          std::string topic= fdef->PlugIn();
          std::string key1=fdef->KeywordAt(1);
          if(topic=="CoreFaudes") {
            topic=fdef->KeywordAt(1);
            key1=fdef->KeywordAt(2);
          }
          if(topic.length()>0) topic.at(0)=toupper(topic.at(0));
          if(key1.length()>0) key1.at(0)=toupper(key1.at(0));
          lhelp.push_back("SwigHelpEntry(\"" + topic + "\", \"" + key1 + "\", \"" +
	    luasig + "\")");
        } else {
          lhelp.push_back("");
        }
      }
      // Filter pseudo doublets (only differ in lrtype)
      for(unsigned int i=1; i<lfdefs.size();i++) {
        unsigned int j;
        for(j=0; j<i; j++) 
  	  if(lfdefs.at(i)==lfdefs.at(j)) break;
        if(j==i) continue; 
        // Invalidate entry?
        if(lrtypes.at(j)=="void") 
          {lfdefs[j]=""; continue;}  
        if(lrtypes.at(i)=="void") 
          {lfdefs[i]=""; continue;}  
      } // Done: prepare per signature

      // Generate swig definitions: write
      int lcount=0;
      for(unsigned int i=0; i<lfdefs.size(); i++) {
        if(lfdefs.at(i)=="") continue;
        swigheader << lrtypes.at(i) << " " << lfdefs.at(i) << ";" << std::endl;
        lcount++;
        if(lhelp.at(i)=="") continue; 
        swigheader << lhelp.at(i) << ";" << std::endl;
      }
      std::cout << "rti2code: generating swig interface for function \"" << fdef->Name() << "\"" << 
      " #" << lcount << " variants" << std::endl;

      // End all signatures, incl conditional
      if(!flat) {
        swigheader << "#endif " << std::endl;
      }  
      swigheader << std::endl;
    } // endif swig


  } // loop all functions

  // C++ class definition: function class: all such done
  if(loader) {
    rtiheader << "} // namespace" << std::endl;
  }

  // C++ class definition: register function prototypes: done
  if(loader) {
    rticode << "}" << std::endl;
    rticode << "} // namespace" << std::endl;
  }

  return(0);
}
