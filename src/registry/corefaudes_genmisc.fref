<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE ReferencePage SYSTEM "http://www.faudes.org/dtd/1.0/referencepage.dtd">
<ReferencePage chapter="Reference" section="CoreFaudes" page="10_Miscellaneous" title="CoreFaudes - Misc">
<h1>
Misc Functions on Generators
</h1>

<!-- ===================================================== -->
<!-- ===================================================== -->
<!-- ===================================================== -->
<!-- ===================================================== -->


<ffnct_reference name="EmptyLanguage">

<fdetails/>
<p>
Returns a generator <fimath>G</fimath> with the specified alphabet <fimath>\Sigma</fimath>,
no states and no transitions; i.e., we have <fimath>L_m(G)=L(G)=\emptyset</fimath>. 
</p>

<fconditions/>
<p>
The empty language generator is deterministic.
</p>

</ffnct_reference>

<!-- ===================================================== -->
<!-- ===================================================== -->
<!-- ===================================================== -->
<!-- ===================================================== -->

<ffnct_reference name="IsEmptyLanguage">

<fconditions/>
<p>
The argument may be non-deterministic.
</p>

</ffnct_reference>

<!-- ===================================================== -->
<!-- ===================================================== -->
<!-- ===================================================== -->
<!-- ===================================================== -->

<ffnct_reference name="Automaton">
<fdetails/>
<p>
Converts the given generator G to a formal automaton that marks the
same marked language <fimath>L_m(G)</fimath> while accepting any 
input string, i.e. <fimath>L(G)=\Sigma^*</fimath>. 
This is achieved by introducing a dump state to represent 
<fimath>\Sigma^* - \Closure{L_m(G)}</fimath>.
</p>
<p>
<b>Note.</b>
In libFAUDES pre 2.33, we used to preprocess by <ffnct>Trim</ffnct>
in order to gain performance. This was dropped so you may want to invoke
<ffnct>Trim</ffnct> explicitly. The rational was to become agnostic to
alternative acceptance conditions.
</p>  

<fexample/>
<table class="images"> 
<tr> <td> G </td> <td> GRes  </td> </tr>
<tr>
<td> <fimage fsrc="tmp_automaton_g"/> </td> 
<td> <fimage fsrc="tmp_automaton_gRes"/> </td> 
</tr>
</table> 


<fconditions/>
<p> 
The provided generator is assumed to be deterministic. The resulting generator
is guaranteed to be deterministic.
</p>


</ffnct_reference>

<!-- ===================================================== -->
<!-- ===================================================== -->
<!-- ===================================================== -->

<ffnct_reference name="IsClosed">
<fdetails/>
<p>
A language <fimath>L</fimath> is <i>prefix-closed</i>
if for each string <fimath>s\in L</fimath> all prefixes <fimath>r\le s</fimath> 
are also element of <fimath>L</fimath>:
<br/>
<br/>
<fdmath>s\in L \text{ and } r\le s \quad \Rightarrow\quad r\in L</fdmath>.
<br/>
<br/>
The function <ffnct>IsClosed</ffnct> tests whether the language
<fimath>L_m(G)</fimath> marked by the specified generator <i>G</i> is
prefix-closed. It does so by testing whether any state that
is accessible and co-accessible also is marked. 
For deterministic generators, this condition is
sufficient and necessary. In general, it is only sufficient.
</p>

<fexample/>
<table class="images"> 
<tr> <td> G </td> </tr>
<tr>
<td> <fimage fsrc="tmp_prefixclosure_g"/> </td> 
</tr>
</table> 
<p>
The language <fimath>L_m(G)</fimath> marked by the above generator is not
prefix-closed, since the states <tt>1</tt>, <tt>2</tt> and <tt>4</tt> are accessible
and co-accessible but not marked. For example, the string 
<tt>ac</tt><fimath>\nin L_m(G)</fimath> is a
prefix of <tt>acbb</tt><fimath>\in L_m(G)</fimath>.
</p>

</ffnct_reference>


<!-- ===================================================== -->
<!-- ===================================================== -->
<!-- ===================================================== -->

<ffnct_reference name="PrefixClosure">
<fdetails/>
<p>
For any language <fimath>L</fimath> there exists a smallest prefix-closed
superset, the so-called <i>prefix-closure</i> of <fimath>L</fimath>:
<br/>
<br/>
<fdmath>\Closure{L}:=\{ r \in \Sigma*|\ \exists s\in L\ :\  r\le s\}</fdmath>.
<br/>
</p>
<p>
This function computes a realisation of the prefix-closure of
<fimath>L_m(GArg)</fimath> by first erasing all states that are not co-accessible 
and then marking the remaining states.
</p>

<fexample/>
<table class="images"> 
<tr> <td> G </td> <td> GRes  </td> </tr>
<tr>
<td> <fimage fsrc="tmp_prefixclosure_g"/> &nbsp;&nbsp;</td> 
<td> <fimage fsrc="tmp_prefixclosure_gRes"/> </td> 
</tr>
</table> 

</ffnct_reference>


<!-- ===================================================== -->
<!-- ===================================================== -->
<!-- ===================================================== -->

<ffnct_reference name="ApplyRelabelMap">
<fdetails/>
<p>
A <ftype>RelabelMap</ftype> is a set valued map with domain and range <ftype>EventSet</ftype>.
It is used to represent re-labeling a scheme.
To maintain an event, it must be excluded from the domain.
To remove an event, it shall be mapped to the empty set.
For a one-to-one replacement, use singleton target sets.
Examples are given in the Lua-faudes tutorials <tt>1_containers.lua</tt> and
<tt>2_generators.lua</tt>.
</p>

<fexample/>

The figure shows the scheme  "a->x, b->{z,y} and c->{}".
<table class="images"> 
<tr> <td> G </td> <td> GRes  </td> </tr>
<tr>
<td> <fimage fsrc="tmp_toberelabeled"/> &nbsp;&nbsp;</td> 
<td> <fimage fsrc="tmp_relabeled"/> </td> 
</tr>
</table> 

</ffnct_reference>




</ReferencePage>

  
